# Optimized Badge Update Workflow for mypylogger v0.2.0
#
# Enhanced badge generation and update system with reliability, speed, and consistency.
# Implements smart caching, conflict prevention, and fallback mechanisms.
#
# Requirements Addressed:
# - 6.1: Reliable badge data persistence and retrieval
# - 6.2: Generate badges within 2 minutes of workflow completion
# - 6.3: Add fallback mechanisms for badge generation failures
# - 6.4: Ensure badge data consistency across all workflows
# - 6.5: Prevent badge update conflicts with improved synchronization

name: Enhanced Badge Updates

# Optimized trigger configuration for faster response
on:
  workflow_run:
    workflows: ["Quality Gate", "Security Scanning", "Documentation (Optimized)", "Publish to PyPI"]
    types: [completed]
    branches: [main]
  workflow_dispatch:  # Allow manual badge updates
    inputs:
      force_update:
        description: 'Force update all badges (ignore cache)'
        required: false
        type: boolean
        default: false

# Enhanced permissions for secure badge management
permissions:
  contents: write
  actions: read
  pull-requests: read

# Optimized environment for fast execution
env:
  BADGE_UPDATE_TIMEOUT: "120"  # 2 minutes target
  CACHE_ENABLED: "true"
  FALLBACK_ENABLED: "true"

# Global defaults
defaults:
  run:
    shell: bash

# Prevent concurrent badge updates to avoid conflicts
concurrency:
  group: badge-updates
  cancel-in-progress: false

jobs:
  # Job 1: Fast Badge Generation with Enhanced Reliability
  generate-badges:
    name: Generate Enhanced Badges
    runs-on: ubuntu-latest
    timeout-minutes: 3  # Reduced to 3 minutes for faster execution
    
    outputs:
      badges-generated: ${{ steps.badge-summary.outputs.badges-generated }}
      generation-time: ${{ steps.badge-summary.outputs.total-time }}
      cache-hit-rate: ${{ steps.badge-summary.outputs.cache-hit-rate }}
    
    steps:
      - name: Checkout repository with optimized settings
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 1
      
      - name: Initialize enhanced badge generation environment
        run: |
          echo "🚀 ENHANCED BADGE GENERATION SYSTEM"
          echo "=================================="
          echo "Triggered by: ${{ github.event.workflow_run.name || 'Manual' }}"
          echo "Target time: <2 minutes"
          echo "Cache enabled: ${{ env.CACHE_ENABLED }}"
          echo "Fallback enabled: ${{ env.FALLBACK_ENABLED }}"
          echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo ""
          
          # Record start time for performance tracking
          echo "BADGE_GENERATION_START=$(date +%s)" >> $GITHUB_ENV
          
          # Create optimized directory structure
          mkdir -p .github/badges
          mkdir -p badge-data
          mkdir -p .badge-cache
          
          # Install required tools efficiently
          sudo apt-get update -qq && sudo apt-get install -y -qq jq bc curl
          
          echo "✅ Environment initialized for enhanced badge generation"
      
      # Implement conflict prevention and smart locking
      - name: Acquire badge update lock
        uses: ./.github/actions/badge-conflict-prevention
        with:
          operation: 'lock'
          timeout: '180'  # 3 minutes timeout
      
      # Smart scheduling to reduce update frequency
      - name: Smart badge update scheduling
        id: schedule-check
        uses: ./.github/actions/smart-badge-scheduler
        with:
          schedule-mode: 'smart'
          min-interval: '300'  # 5 minutes minimum
          max-updates-per-hour: '12'
          priority: ${{ github.event.workflow_run.conclusion == 'failure' && 'high' || 'normal' }}
      
      # Skip badge generation if throttled
      - name: Check if update should proceed
        run: |
          SHOULD_UPDATE="${{ steps.schedule-check.outputs.should-update }}"
          THROTTLE_REASON="${{ steps.schedule-check.outputs.throttle-reason }}"
          
          if [ "$SHOULD_UPDATE" = "false" ]; then
            echo "⏸️ Badge update throttled: $THROTTLE_REASON"
            echo "Next update time: $(date -d @${{ steps.schedule-check.outputs.next-update-time }} 2>/dev/null || echo 'Unknown')"
            echo "SKIP_BADGE_UPDATE=true" >> $GITHUB_ENV
          else
            echo "✅ Badge update approved by smart scheduler"
            echo "SKIP_BADGE_UPDATE=false" >> $GITHUB_ENV
          fi
      
      # Check cache status before generation
      - name: Check badge cache status
        if: env.SKIP_BADGE_UPDATE != 'true'
        uses: ./.github/actions/badge-cache-manager
        with:
          operation: 'check'
          cache-duration: '300'  # 5 minutes cache
      
      # Smart artifact download with timeout and retry
      - name: Download workflow artifacts with smart caching
        id: download-artifacts
        timeout-minutes: 1  # Fast timeout for artifact download
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Get triggering workflow information
            const workflowRun = context.payload.workflow_run;
            if (!workflowRun) {
              console.log('Manual trigger - no workflow artifacts to download');
              return;
            }
            
            console.log(`🔍 Downloading artifacts from: ${workflowRun.name} (${workflowRun.id})`);
            console.log(`Workflow status: ${workflowRun.conclusion}`);
            
            try {
              // List artifacts with timeout
              const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: workflowRun.id,
              });
              
              console.log(`📦 Found ${artifacts.data.artifacts.length} artifacts`);
              
              // Filter relevant badge artifacts
              const badgeArtifacts = artifacts.data.artifacts.filter(artifact => 
                artifact.name.includes('badge') || 
                artifact.name.includes('coverage') ||
                artifact.name.includes('performance') ||
                artifact.name.includes('security') ||
                artifact.name.includes('consolidated')
              );
              
              console.log(`🏷️ Badge-related artifacts: ${badgeArtifacts.length}`);
              
              // Download artifacts with error handling
              let downloadCount = 0;
              for (const artifact of badgeArtifacts.slice(0, 5)) {  // Limit to 5 for speed
                try {
                  console.log(`⬇️ Downloading: ${artifact.name}`);
                  
                  const download = await github.rest.actions.downloadArtifact({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    artifact_id: artifact.id,
                    archive_format: 'zip',
                  });
                  
                  fs.writeFileSync(`${artifact.name}.zip`, Buffer.from(download.data));
                  downloadCount++;
                  console.log(`✅ Downloaded: ${artifact.name}.zip`);
                } catch (error) {
                  console.log(`⚠️ Failed to download ${artifact.name}: ${error.message}`);
                }
              }
              
              console.log(`📊 Successfully downloaded ${downloadCount} artifacts`);
              
            } catch (error) {
              console.log(`❌ Artifact download failed: ${error.message}`);
              console.log('Will proceed with fallback badge generation');
            }
      
      # Fast artifact extraction and processing
      - name: Extract and process badge data efficiently
        run: |
          echo "⚡ Fast badge data extraction and processing..."
          echo "============================================="
          
          # Initialize processing tracking
          EXTRACTED_COUNT=0
          PROCESSED_COUNT=0
          
          # Extract artifacts quickly
          for zip_file in *.zip; do
            if [ -f "$zip_file" ]; then
              echo "📦 Extracting: $zip_file"
              unzip -q -o "$zip_file" -d extracted/ 2>/dev/null || echo "⚠️ Extraction warning for $zip_file"
              EXTRACTED_COUNT=$((EXTRACTED_COUNT + 1))
            fi
          done
          
          echo "📊 Extracted $EXTRACTED_COUNT artifact files"
          
          # Process badge data files efficiently
          if [ -d "extracted" ]; then
            echo "🔄 Processing extracted badge data..."
            
            # Find and process JSON files
            find extracted/ -name "*.json" -type f 2>/dev/null | while read -r badge_file; do
              if [ -f "$badge_file" ]; then
                filename=$(basename "$badge_file")
                
                # Smart badge file mapping
                case "$filename" in
                  *"build"*|*"status"*)
                    cp "$badge_file" badge-data/build-badge-data.json 2>/dev/null
                    echo "✅ Build badge data processed"
                    ;;
                  *"coverage"*)
                    cp "$badge_file" badge-data/coverage-badge-data.json 2>/dev/null
                    echo "✅ Coverage badge data processed"
                    ;;
                  *"security"*)
                    cp "$badge_file" badge-data/security-badge-data.json 2>/dev/null
                    echo "✅ Security badge data processed"
                    ;;
                  *"performance"*)
                    cp "$badge_file" badge-data/performance-badge-data.json 2>/dev/null
                    echo "✅ Performance badge data processed"
                    ;;
                  *"docs"*|*"documentation"*)
                    cp "$badge_file" badge-data/docs-badge-data.json 2>/dev/null
                    echo "✅ Documentation badge data processed"
                    ;;
                esac
                
                PROCESSED_COUNT=$((PROCESSED_COUNT + 1))
              fi
            done
          fi
          
          echo "📊 Processed $PROCESSED_COUNT badge data files"
          echo "✅ Badge data extraction completed"
      
      # Generate all badges using enhanced badge generator (only if not throttled)
      - name: Generate build status badge
        if: env.SKIP_BADGE_UPDATE != 'true'
        uses: ./.github/actions/enhanced-badge-generator
        with:
          badge-type: 'build'
          workflow-status: ${{ github.event.workflow_run.conclusion || 'success' }}
          cache-enabled: ${{ env.CACHE_ENABLED }}
          fallback-enabled: ${{ env.FALLBACK_ENABLED }}
      
      - name: Generate coverage badge
        if: env.SKIP_BADGE_UPDATE != 'true'
        uses: ./.github/actions/enhanced-badge-generator
        with:
          badge-type: 'coverage'
          badge-data: ${{ steps.extract-coverage-data.outputs.coverage-data || '{}' }}
          workflow-status: ${{ github.event.workflow_run.conclusion || 'success' }}
          cache-enabled: ${{ env.CACHE_ENABLED }}
          fallback-enabled: ${{ env.FALLBACK_ENABLED }}
      
      - name: Generate security badge
        if: env.SKIP_BADGE_UPDATE != 'true'
        uses: ./.github/actions/enhanced-badge-generator
        with:
          badge-type: 'security'
          workflow-status: ${{ github.event.workflow_run.conclusion || 'success' }}
          cache-enabled: ${{ env.CACHE_ENABLED }}
          fallback-enabled: ${{ env.FALLBACK_ENABLED }}
      
      - name: Generate performance badge with regression detection
        if: env.SKIP_BADGE_UPDATE != 'true'
        uses: ./.github/actions/enhanced-badge-generator
        with:
          badge-type: 'performance'
          badge-data: ${{ steps.extract-performance-data.outputs.performance-data || '{}' }}
          workflow-status: ${{ github.event.workflow_run.conclusion || 'success' }}
          cache-enabled: ${{ env.CACHE_ENABLED }}
          fallback-enabled: ${{ env.FALLBACK_ENABLED }}
      
      - name: Generate documentation badge
        if: env.SKIP_BADGE_UPDATE != 'true'
        uses: ./.github/actions/enhanced-badge-generator
        with:
          badge-type: 'docs'
          workflow-status: ${{ github.event.workflow_run.conclusion || 'success' }}
          cache-enabled: ${{ env.CACHE_ENABLED }}
          fallback-enabled: ${{ env.FALLBACK_ENABLED }}
      
      # Extract badge data for enhanced generation
      - name: Extract coverage data for badge generation
        id: extract-coverage-data
        run: |
          echo "📊 Extracting coverage data for badge generation..."
          
          COVERAGE_DATA="{}"
          
          # Look for coverage data in extracted files
          if [ -f "badge-data/coverage-badge-data.json" ]; then
            COVERAGE_DATA=$(cat badge-data/coverage-badge-data.json)
            echo "✅ Found coverage data"
          elif [ -f "extracted/coverage.json" ]; then
            # Extract coverage percentage from coverage.json
            COVERAGE_PERCENT=$(jq -r '.totals.percent_covered // 0' extracted/coverage.json 2>/dev/null || echo "0")
            COVERAGE_DATA="{\"coverage_percent\": $COVERAGE_PERCENT}"
            echo "✅ Extracted coverage from coverage.json: ${COVERAGE_PERCENT}%"
          else
            echo "⚠️ No coverage data found - will use fallback"
          fi
          
          echo "coverage-data=$COVERAGE_DATA" >> $GITHUB_OUTPUT
      
      - name: Extract performance data for badge generation
        id: extract-performance-data
        run: |
          echo "🚀 Extracting performance data for badge generation..."
          
          PERFORMANCE_DATA="{}"
          
          # Look for performance data in extracted files
          if [ -f "badge-data/performance-badge-data.json" ]; then
            PERFORMANCE_DATA=$(cat badge-data/performance-badge-data.json)
            echo "✅ Found performance badge data"
          elif [ -f "extracted/benchmark.json" ]; then
            echo "📊 Processing benchmark results for performance badge..."
            
            # Use performance badge generation script if available
            if [ -f "scripts/generate_performance_badge.py" ]; then
              # Install Python for badge generation
              sudo apt-get install -y python3 python3-pip -qq
              
              # Generate performance data
              if python3 scripts/generate_performance_badge.py "extracted/benchmark.json" "none" "badge-data/"; then
                if [ -f "badge-data/performance-summary.json" ]; then
                  PERFORMANCE_DATA=$(jq '.badge_data' badge-data/performance-summary.json 2>/dev/null || echo "{}")
                  echo "✅ Generated performance data from benchmarks"
                fi
              fi
            else
              echo "⚠️ Performance script not found - using basic data"
              PERFORMANCE_DATA='{"status": "unknown"}'
            fi
          else
            echo "⚠️ No performance data found - will use fallback"
          fi
          
          echo "performance-data=$PERFORMANCE_DATA" >> $GITHUB_OUTPUT
      
      # Generate comprehensive badge summary
      - name: Generate badge generation summary
        id: badge-summary
        run: |
          echo "📊 BADGE GENERATION SUMMARY"
          echo "=========================="
          
          # Calculate total generation time
          BADGE_END_TIME=$(date +%s)
          TOTAL_TIME=$((BADGE_END_TIME - BADGE_GENERATION_START))
          
          echo "Total generation time: ${TOTAL_TIME}s"
          echo "Target time: 120s (2 minutes)"
          
          # Count generated badges
          BADGE_COUNT=0
          CACHE_HITS=0
          FALLBACK_COUNT=0
          
          for badge_file in .github/badges/*.json; do
            if [ -f "$badge_file" ]; then
              BADGE_COUNT=$((BADGE_COUNT + 1))
              
              # Check if badge was generated from cache
              if jq -e '.cached // false' "$badge_file" >/dev/null 2>&1; then
                CACHE_HITS=$((CACHE_HITS + 1))
              fi
              
              # Check if badge is fallback
              if jq -e '.fallback // false' "$badge_file" >/dev/null 2>&1; then
                FALLBACK_COUNT=$((FALLBACK_COUNT + 1))
              fi
            fi
          done
          
          # Calculate cache hit rate
          if [ $BADGE_COUNT -gt 0 ]; then
            CACHE_HIT_RATE=$(echo "scale=1; $CACHE_HITS * 100 / $BADGE_COUNT" | bc -l 2>/dev/null || echo "0")
          else
            CACHE_HIT_RATE="0"
          fi
          
          echo "📋 Generation Statistics:"
          echo "======================="
          echo "Badges generated: $BADGE_COUNT"
          echo "Cache hits: $CACHE_HITS"
          echo "Cache hit rate: ${CACHE_HIT_RATE}%"
          echo "Fallback badges: $FALLBACK_COUNT"
          
          # Performance validation
          if [ $TOTAL_TIME -le 120 ]; then
            echo "✅ Performance target achieved (${TOTAL_TIME}s ≤ 120s)"
            PERFORMANCE_STATUS="excellent"
          elif [ $TOTAL_TIME -le 180 ]; then
            echo "⚠️ Performance acceptable (${TOTAL_TIME}s ≤ 180s)"
            PERFORMANCE_STATUS="good"
          else
            echo "❌ Performance needs improvement (${TOTAL_TIME}s > 180s)"
            PERFORMANCE_STATUS="needs-improvement"
          fi
          
          # Set outputs
          echo "badges-generated=$BADGE_COUNT" >> $GITHUB_OUTPUT
          echo "total-time=$TOTAL_TIME" >> $GITHUB_OUTPUT
          echo "cache-hit-rate=$CACHE_HIT_RATE" >> $GITHUB_OUTPUT
          echo "performance-status=$PERFORMANCE_STATUS" >> $GITHUB_OUTPUT
          
          echo ""
          echo "🏷️ Generated Badge Files:"
          echo "========================"
          ls -la .github/badges/*.json 2>/dev/null || echo "No badge files found"
      
      # Upload generated badges as artifacts
      - name: Upload generated badges
        uses: actions/upload-artifact@v4
        with:
          name: generated-badges
          path: |
            .github/badges/
            badge-data/
            .badge-cache/
          retention-days: 7
      
      # Validate all generated badges
      - name: Validate badge consistency and quality
        run: |
          echo "🔍 BADGE VALIDATION AND CONSISTENCY CHECK"
          echo "========================================"
          
          VALIDATION_ERRORS=0
          VALIDATED_BADGES=0
          
          for badge_file in .github/badges/*.json; do
            if [ -f "$badge_file" ]; then
              badge_name=$(basename "$badge_file" .json)
              echo "🔍 Validating: $badge_name"
              
              # JSON syntax validation
              if ! jq empty "$badge_file" 2>/dev/null; then
                echo "❌ Invalid JSON syntax in $badge_name"
                VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
                continue
              fi
              
              # Required fields validation
              SCHEMA=$(jq -r '.schemaVersion // "missing"' "$badge_file")
              LABEL=$(jq -r '.label // "missing"' "$badge_file")
              MESSAGE=$(jq -r '.message // "missing"' "$badge_file")
              COLOR=$(jq -r '.color // "missing"' "$badge_file")
              
              if [[ "$SCHEMA" = "missing" || "$LABEL" = "missing" || "$MESSAGE" = "missing" || "$COLOR" = "missing" ]]; then
                echo "❌ Missing required fields in $badge_name"
                VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
                continue
              fi
              
              # Shields.io compatibility validation
              if [ "$SCHEMA" != "1" ]; then
                echo "❌ Invalid schema version in $badge_name (expected: 1, got: $SCHEMA)"
                VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
                continue
              fi
              
              echo "✅ $badge_name: Valid (label: $LABEL, message: $MESSAGE, color: $COLOR)"
              VALIDATED_BADGES=$((VALIDATED_BADGES + 1))
            fi
          done
          
          echo ""
          echo "📊 Validation Summary:"
          echo "===================="
          echo "Badges validated: $VALIDATED_BADGES"
          echo "Validation errors: $VALIDATION_ERRORS"
          
          if [ $VALIDATION_ERRORS -eq 0 ]; then
            echo "✅ All badges passed validation"
          else
            echo "❌ Badge validation failed with $VALIDATION_ERRORS errors"
            echo "Please review badge generation process"
          fi
      
      # Update README with enhanced badge display
      - name: Update README with enhanced badge display
        run: |
          echo "📝 Updating README with enhanced badge display..."
          echo "=============================================="
          
          # Check if README update script exists
          if [ -f "scripts/update_readme_badges.py" ]; then
            echo "🔧 Using enhanced README badge update script..."
            
            # Install Python for README updates
            sudo apt-get install -y python3 -qq
            
            # Make script executable
            chmod +x scripts/update_readme_badges.py
            
            # Run README update with repository name and enhanced options
            if python3 scripts/update_readme_badges.py "${{ github.repository }}"; then
              echo "✅ README updated with enhanced badge display"
              
              # Validate README changes
              if git diff --quiet README.md; then
                echo "📋 No README changes needed (badges already up to date)"
              else
                echo "📝 README updated with new badge URLs"
                git diff --stat README.md
              fi
            else
              echo "⚠️ README update failed - continuing with badge updates"
            fi
          else
            echo "⚠️ README update script not found - creating basic badge section"
            
            # Create basic badge section if script not available
            if [ -f "README.md" ]; then
              echo "📝 Adding basic badge section to README..."
              
              # Check if badges already exist
              if ! grep -q "shields.io" README.md; then
                # Add badges after title
                sed -i '1a\\n<!-- BADGES START -->\n![Build](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/${{ github.repository }}/main/.github/badges/build.json)\n![Coverage](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/${{ github.repository }}/main/.github/badges/coverage.json)\n![Security](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/${{ github.repository }}/main/.github/badges/security.json)\n![Performance](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/${{ github.repository }}/main/.github/badges/performance.json)\n<!-- BADGES END -->\n' README.md
                echo "✅ Basic badges added to README"
              fi
            fi
          fi
          
          echo "✅ README badge update process completed"
  
  # Job 2: Conflict-Free Badge Commit with Enhanced Synchronization
  commit-badges:
    name: Commit Badges (Conflict-Free)
    runs-on: ubuntu-latest
    needs: generate-badges
    if: needs.generate-badges.outputs.badges-generated > 0 && needs.generate-badges.result == 'success'
    timeout-minutes: 2  # Fast commit process
    
    steps:
      - name: Checkout with enhanced conflict prevention
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0  # Full history for conflict resolution
      
      - name: Download generated badges
        uses: actions/download-artifact@v4
        with:
          name: generated-badges
          path: .github/badges/
        continue-on-error: true
      
      # Update badge cache after successful generation
      - name: Update badge cache
        uses: ./.github/actions/badge-cache-manager
        with:
          operation: 'update'
          cache-duration: '300'
      
      # Synchronize badge updates to prevent conflicts
      - name: Synchronize badge updates
        uses: ./.github/actions/badge-synchronizer
        with:
          sync-mode: 'queue'
          max-wait-time: '120'
      
      # Monitor for conflicts before committing
      - name: Monitor for badge conflicts
        uses: ./.github/actions/badge-conflict-prevention
        with:
          operation: 'monitor'
      
      - name: Enhanced conflict-free badge commit
        run: |
          echo "💾 ENHANCED CONFLICT-FREE BADGE COMMIT"
          echo "====================================="
          echo "Badges to commit: ${{ needs.generate-badges.outputs.badges-generated }}"
          echo "Generation time: ${{ needs.generate-badges.outputs.generation-time }}s"
          echo "Cache hit rate: ${{ needs.generate-badges.outputs.cache-hit-rate }}%"
          echo ""
          
          # Configure git with enhanced settings
          git config --local user.email "action@github.com"
          git config --local user.name "Enhanced Badge Generator"
          git config --local pull.rebase true
          git config --local push.default simple
          
          # Enhanced conflict prevention strategy
          echo "🔄 Implementing enhanced conflict prevention..."
          
          # Step 1: Fetch latest changes
          git fetch origin main --depth=10
          
          # Step 2: Check for conflicts before committing
          if ! git diff --quiet origin/main HEAD -- .github/badges/; then
            echo "⚠️ Potential conflicts detected - implementing smart resolution"
            
            # Smart conflict resolution: preserve remote changes, apply our updates
            git checkout origin/main -- .github/badges/ 2>/dev/null || echo "No remote badge changes"
          fi
          
          # Step 3: Apply our badge updates
          echo "📝 Applying badge updates..."
          
          # Ensure badge directory exists
          mkdir -p .github/badges
          
          # Copy generated badges (they should already be in place)
          BADGE_FILES_UPDATED=0
          
          for badge_file in .github/badges/*.json; do
            if [ -f "$badge_file" ]; then
              BADGE_FILES_UPDATED=$((BADGE_FILES_UPDATED + 1))
            fi
          done
          
          echo "Badge files ready for commit: $BADGE_FILES_UPDATED"
          
          # Step 4: Smart commit with conflict avoidance
          if git diff --quiet .github/badges/ README.md 2>/dev/null; then
            echo "📋 No badge changes detected - badges are already up to date"
          else
            echo "📝 Badge changes detected - preparing commit..."
            
            # Add only badge-related files
            git add .github/badges/
            git add README.md 2>/dev/null || echo "No README changes"
            
            # Check if there are staged changes
            if ! git diff --staged --quiet; then
              # Create atomic commit with enhanced metadata
              COMMIT_MESSAGE="ci: update status badges (enhanced) 

🏷️ Badge Update Summary:
- Badges updated: ${{ needs.generate-badges.outputs.badges-generated }}
- Generation time: ${{ needs.generate-badges.outputs.generation-time }}s (target: ≤120s)
- Cache hit rate: ${{ needs.generate-badges.outputs.cache-hit-rate }}%
- Triggered by: ${{ github.event.workflow_run.name || 'Manual' }}
- Workflow run: ${{ github.event.workflow_run.id || github.run_id }}
- Commit: ${{ github.event.workflow_run.head_sha || github.sha }}
- Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')

[skip ci]"
              
              # Commit with retry mechanism
              COMMIT_ATTEMPTS=0
              MAX_ATTEMPTS=3
              
              while [ $COMMIT_ATTEMPTS -lt $MAX_ATTEMPTS ]; do
                COMMIT_ATTEMPTS=$((COMMIT_ATTEMPTS + 1))
                echo "Commit attempt $COMMIT_ATTEMPTS/$MAX_ATTEMPTS..."
                
                if git commit -m "$COMMIT_MESSAGE"; then
                  echo "✅ Commit successful on attempt $COMMIT_ATTEMPTS"
                  break
                else
                  echo "⚠️ Commit failed on attempt $COMMIT_ATTEMPTS"
                  
                  if [ $COMMIT_ATTEMPTS -lt $MAX_ATTEMPTS ]; then
                    echo "Retrying after brief delay..."
                    sleep 2
                    
                    # Refresh and try again
                    git fetch origin main
                    git rebase origin/main 2>/dev/null || {
                      echo "Rebase failed - using merge strategy"
                      git merge origin/main --no-edit 2>/dev/null || echo "Merge not needed"
                    }
                  fi
                fi
              done
              
              # Push with retry mechanism
              echo "📤 Pushing badge updates with conflict prevention..."
              
              PUSH_ATTEMPTS=0
              MAX_PUSH_ATTEMPTS=3
              
              while [ $PUSH_ATTEMPTS -lt $MAX_PUSH_ATTEMPTS ]; do
                PUSH_ATTEMPTS=$((PUSH_ATTEMPTS + 1))
                echo "Push attempt $PUSH_ATTEMPTS/$MAX_PUSH_ATTEMPTS..."
                
                if git push origin main; then
                  echo "✅ Push successful on attempt $PUSH_ATTEMPTS"
                  echo "🎉 Badge updates committed and pushed successfully!"
                  break
                else
                  echo "⚠️ Push failed on attempt $PUSH_ATTEMPTS"
                  
                  if [ $PUSH_ATTEMPTS -lt $MAX_PUSH_ATTEMPTS ]; then
                    echo "Implementing conflict resolution..."
                    
                    # Pull with rebase to resolve conflicts
                    git pull --rebase origin main 2>/dev/null || {
                      echo "Rebase failed - using merge"
                      git pull origin main --no-edit 2>/dev/null || echo "Pull not needed"
                    }
                    
                    sleep 1
                  else
                    echo "❌ Failed to push after $MAX_PUSH_ATTEMPTS attempts"
                    echo "Manual intervention may be required"
                    exit 1
                  fi
                fi
              done
            else
              echo "📋 No staged changes - nothing to commit"
            fi
          fi
      
      - name: Generate badge commit report
        if: always()
        run: |
          echo "📊 BADGE COMMIT REPORT"
          echo "===================="
          echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "Repository: ${{ github.repository }}"
          echo "Branch: main"
          echo "Triggered by: ${{ github.event.workflow_run.name || 'Manual' }}"
          echo ""
          
          echo "📈 Performance Metrics:"
          echo "====================="
          echo "Total badges: ${{ needs.generate-badges.outputs.badges-generated }}"
          echo "Generation time: ${{ needs.generate-badges.outputs.generation-time }}s"
          echo "Cache hit rate: ${{ needs.generate-badges.outputs.cache-hit-rate }}%"
          echo "Performance status: ${{ needs.generate-badges.outputs.performance-status || 'unknown' }}"
          echo ""
          
          echo "🔗 Badge URLs (Ready for Use):"
          echo "============================="
          echo "Build: https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/${{ github.repository }}/main/.github/badges/build.json"
          echo "Coverage: https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/${{ github.repository }}/main/.github/badges/coverage.json"
          echo "Security: https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/${{ github.repository }}/main/.github/badges/security.json"
          echo "Performance: https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/${{ github.repository }}/main/.github/badges/performance.json"
          echo "Documentation: https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/${{ github.repository }}/main/.github/badges/docs.json"
          echo ""
          
          echo "✅ Enhanced badge update workflow completed successfully!"
      
      # Release badge update lock
      - name: Release badge update lock
        if: always()
        uses: ./.github/actions/badge-conflict-prevention
        with:
          operation: 'unlock'

  # Job for handling throttled updates
  throttled-update-summary:
    name: Throttled Update Summary
    runs-on: ubuntu-latest
    needs: generate-badges
    if: needs.generate-badges.result == 'skipped' || needs.generate-badges.outputs.badges-generated == 0
    timeout-minutes: 1
    
    steps:
      - name: Generate throttled update report
        run: |
          echo "⏸️ BADGE UPDATE THROTTLED"
          echo "========================"
          echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "Repository: ${{ github.repository }}"
          echo "Triggered by: ${{ github.event.workflow_run.name || 'Manual' }}"
          echo ""
          
          echo "📋 Throttling Information:"
          echo "========================="
          echo "Badge updates were throttled by the smart scheduler"
          echo "This helps prevent excessive badge updates and improves performance"
          echo ""
          
          echo "🚀 Benefits of Smart Throttling:"
          echo "==============================="
          echo "- Reduces GitHub API usage"
          echo "- Prevents badge update spam"
          echo "- Improves overall workflow performance"
          echo "- Maintains badge data consistency"
          echo ""
          
          echo "⏰ Next Update:"
          echo "=============="
          echo "Badge updates will resume when the throttling conditions are met"
          echo "Typical scenarios for next update:"
          echo "- After minimum interval (5 minutes)"
          echo "- When hourly limit resets"
          echo "- For high-priority updates (failures)"
          echo ""
          
          echo "✅ Throttling is working as designed to optimize performance"

  # Job 3: Badge Update Summary and Monitoring
  badge-update-summary:
    name: Badge Update Summary
    runs-on: ubuntu-latest
    needs: [generate-badges, commit-badges]
    if: always()
    timeout-minutes: 1
    
    steps:
      - name: Checkout for monitoring
        uses: actions/checkout@v4
      
      # Generate cache performance statistics
      - name: Generate cache performance statistics
        uses: ./.github/actions/badge-cache-manager
        with:
          operation: 'stats'
      
      # Final conflict monitoring
      - name: Final conflict monitoring
        uses: ./.github/actions/badge-conflict-prevention
        with:
          operation: 'monitor'
      
      - name: Generate comprehensive badge update summary
        run: |
          echo "🏷️ ENHANCED BADGE UPDATE SUMMARY"
          echo "==============================="
          echo "Workflow: ${{ github.workflow }}"
          echo "Run ID: ${{ github.run_id }}"
          echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "Repository: ${{ github.repository }}"
          echo ""
          
          echo "📊 Job Results:"
          echo "=============="
          echo "Badge Generation: ${{ needs.generate-badges.result }}"
          echo "Badge Commit: ${{ needs.commit-badges.result }}"
          echo ""
          
          echo "📈 Performance Metrics:"
          echo "====================="
          echo "Badges Generated: ${{ needs.generate-badges.outputs.badges-generated || '0' }}"
          echo "Generation Time: ${{ needs.generate-badges.outputs.generation-time || '0' }}s"
          echo "Cache Hit Rate: ${{ needs.generate-badges.outputs.cache-hit-rate || '0' }}%"
          echo "Target Time: ≤120s (2 minutes)"
          echo ""
          
          # Determine overall success
          if [[ "${{ needs.generate-badges.result }}" == "success" ]]; then
            if [[ "${{ needs.commit-badges.result }}" == "success" || "${{ needs.commit-badges.result }}" == "skipped" ]]; then
              echo "✅ BADGE UPDATE WORKFLOW: SUCCESSFUL"
              echo ""
              echo "🎉 All badges have been successfully updated and are now live!"
              echo ""
              echo "🚀 Enhanced Features Delivered:"
              echo "- ⚡ Fast generation (target: ≤2 minutes)"
              echo "- 🔄 Smart caching for improved performance"
              echo "- 🛡️ Fallback mechanisms for reliability"
              echo "- 🔒 Conflict-free commit process"
              echo "- 📊 Comprehensive monitoring and reporting"
              echo ""
              echo "🔗 Your badges are now available at:"
              echo "https://github.com/${{ github.repository }}/tree/main/.github/badges"
            else
              echo "⚠️ BADGE UPDATE WORKFLOW: PARTIAL SUCCESS"
              echo ""
              echo "✅ Badge generation completed successfully"
              echo "❌ Badge commit failed or was skipped"
              echo ""
              echo "🔧 Possible Issues:"
              echo "- Git conflicts during commit"
              echo "- Permission issues"
              echo "- Network connectivity problems"
            fi
          else
            echo "❌ BADGE UPDATE WORKFLOW: FAILED"
            echo ""
            echo "❌ Badge generation failed"
            echo ""
            echo "🔧 Troubleshooting Steps:"
            echo "1. Check workflow logs for specific errors"
            echo "2. Verify artifact availability from triggering workflow"
            echo "3. Check repository permissions"
            echo "4. Retry workflow manually if needed"
          fi
          
          echo ""
          echo "📋 Next Steps:"
          echo "============="
          echo "1. Verify badges display correctly in README"
          echo "2. Check badge URLs are accessible"
          echo "3. Monitor badge update performance"
          echo "4. Review cache hit rates for optimization opportunities"