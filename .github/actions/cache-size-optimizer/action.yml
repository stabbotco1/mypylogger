name: 'Cache Size Optimizer'
description: 'Optimize cache size and implement intelligent retention policies for maximum efficiency'
inputs:
  optimization-mode:
    description: 'Optimization mode (analyze, optimize, cleanup, monitor)'
    required: false
    default: 'optimize'
  size-threshold-mb:
    description: 'Cache size threshold in MB for optimization'
    required: false
    default: '1024'
  retention-policy:
    description: 'Retention policy (conservative, balanced, aggressive)'
    required: false
    default: 'balanced'
  enable-compression:
    description: 'Enable cache compression (may impact performance)'
    required: false
    default: 'false'

outputs:
  optimization-performed:
    description: 'Whether optimization was performed'
    value: ${{ steps.optimization-result.outputs.performed }}
  size-reduction-mb:
    description: 'Size reduction achieved in MB'
    value: ${{ steps.optimization-result.outputs.reduction }}
  efficiency-improvement:
    description: 'Cache efficiency improvement percentage'
    value: ${{ steps.optimization-result.outputs.efficiency }}

runs:
  using: 'composite'
  steps:
    - name: Initialize cache size optimization
      id: init-optimization
      run: |
        echo "üíæ CACHE SIZE OPTIMIZATION SYSTEM"
        echo "================================="
        echo "Optimization Mode: ${{ inputs.optimization-mode }}"
        echo "Size Threshold: ${{ inputs.size-threshold-mb }}MB"
        echo "Retention Policy: ${{ inputs.retention-policy }}"
        echo "Compression: ${{ inputs.enable-compression }}"
        echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        echo ""
        
        # Create optimization directories
        mkdir -p cache-optimization/{analysis,policies,reports}
        
        # Initialize optimization session
        OPTIMIZATION_SESSION_ID="opt-$(date +%s)-${{ github.run_number }}"
        echo "OPTIMIZATION_SESSION_ID=$OPTIMIZATION_SESSION_ID" >> $GITHUB_ENV
        
        echo "‚úÖ Cache size optimization initialized"
      shell: bash
    
    - name: Analyze current cache usage and efficiency
      if: inputs.optimization-mode == 'analyze' || inputs.optimization-mode == 'optimize' || inputs.optimization-mode == 'monitor'
      id: analyze-cache
      run: |
        echo "üîç CACHE USAGE ANALYSIS"
        echo "======================"
        
        # Analyze cache directories and their efficiency
        CACHE_DIRS=(
          "$HOME/.cache/uv:UV Dependencies:high"
          "$HOME/.cache/pip:Pip Packages:high"
          "$HOME/.mypy_cache:MyPy Cache:medium"
          "$HOME/.ruff_cache:Ruff Cache:medium"
          "$HOME/.pytest_cache:Pytest Cache:low"
          "$HOME/.cache/pre-commit:Pre-commit:low"
        )
        
        TOTAL_SIZE_MB=0
        TOTAL_FILES=0
        CACHE_ANALYSIS=""
        
        echo "üìä Cache Directory Analysis:"
        echo "=========================="
        
        for cache_entry in "${CACHE_DIRS[@]}"; do
          IFS=':' read -r cache_dir cache_name priority <<< "$cache_entry"
          
          if [ -d "$cache_dir" ]; then
            # Get detailed cache statistics
            SIZE_MB=$(du -sm "$cache_dir" 2>/dev/null | cut -f1 || echo "0")
            FILE_COUNT=$(find "$cache_dir" -type f 2>/dev/null | wc -l || echo "0")
            
            # Calculate cache age (days since last modification)
            LAST_MODIFIED=$(find "$cache_dir" -type f -exec stat -c %Y {} \; 2>/dev/null | sort -n | tail -1 || echo "0")
            CURRENT_TIME=$(date +%s)
            AGE_DAYS=$(( (CURRENT_TIME - LAST_MODIFIED) / 86400 ))
            
            # Calculate efficiency score (size vs usage)
            EFFICIENCY_SCORE=0
            if [ $SIZE_MB -gt 0 ] && [ $FILE_COUNT -gt 0 ]; then
              # Higher score for smaller size per file and recent usage
              SIZE_PER_FILE=$((SIZE_MB * 1000 / FILE_COUNT))  # KB per file
              
              if [ $AGE_DAYS -le 1 ]; then
                RECENCY_SCORE=100
              elif [ $AGE_DAYS -le 7 ]; then
                RECENCY_SCORE=80
              elif [ $AGE_DAYS -le 30 ]; then
                RECENCY_SCORE=50
              else
                RECENCY_SCORE=20
              fi
              
              # Efficiency based on size and recency
              if [ $SIZE_PER_FILE -le 100 ]; then  # <100KB per file
                SIZE_EFFICIENCY=100
              elif [ $SIZE_PER_FILE -le 500 ]; then  # <500KB per file
                SIZE_EFFICIENCY=80
              elif [ $SIZE_PER_FILE -le 1000 ]; then  # <1MB per file
                SIZE_EFFICIENCY=60
              else
                SIZE_EFFICIENCY=40
              fi
              
              EFFICIENCY_SCORE=$(( (RECENCY_SCORE + SIZE_EFFICIENCY) / 2 ))
            fi
            
            TOTAL_SIZE_MB=$((TOTAL_SIZE_MB + SIZE_MB))
            TOTAL_FILES=$((TOTAL_FILES + FILE_COUNT))
            
            echo "- $cache_name:"
            echo "  Size: ${SIZE_MB}MB | Files: ${FILE_COUNT} | Age: ${AGE_DAYS}d | Efficiency: ${EFFICIENCY_SCORE}% | Priority: $priority"
            
            # Store analysis data
            CACHE_ANALYSIS="${CACHE_ANALYSIS}${cache_name}:${SIZE_MB}:${FILE_COUNT}:${AGE_DAYS}:${EFFICIENCY_SCORE}:${priority},"
            
          else
            echo "- $cache_name: Not found"
          fi
        done
        
        echo ""
        echo "üìà Overall Cache Statistics:"
        echo "=========================="
        echo "- Total Size: ${TOTAL_SIZE_MB}MB"
        echo "- Total Files: ${TOTAL_FILES}"
        echo "- Size Threshold: ${{ inputs.size-threshold-mb }}MB"
        
        # Determine if optimization is needed
        OPTIMIZATION_NEEDED=false
        if [ $TOTAL_SIZE_MB -gt ${{ inputs.size-threshold-mb }} ]; then
          OPTIMIZATION_NEEDED=true
          EXCESS_SIZE=$((TOTAL_SIZE_MB - ${{ inputs.size-threshold-mb }}))
          echo "- Status: OPTIMIZATION NEEDED (${EXCESS_SIZE}MB over threshold)"
        else
          echo "- Status: Within threshold limits"
        fi
        
        # Store analysis results
        cat > cache-optimization/analysis/cache-analysis.json << EOF
        {
          "session_id": "$OPTIMIZATION_SESSION_ID",
          "timestamp": "$(date -u '+%Y-%m-%d %H:%M:%S UTC')",
          "total_size_mb": $TOTAL_SIZE_MB,
          "total_files": $TOTAL_FILES,
          "threshold_mb": ${{ inputs.size-threshold-mb }},
          "optimization_needed": $OPTIMIZATION_NEEDED,
          "cache_breakdown": "$CACHE_ANALYSIS"
        }
        EOF
        
        # Set environment variables for next steps
        echo "TOTAL_SIZE_MB=$TOTAL_SIZE_MB" >> $GITHUB_ENV
        echo "OPTIMIZATION_NEEDED=$OPTIMIZATION_NEEDED" >> $GITHUB_ENV
        echo "CACHE_ANALYSIS=$CACHE_ANALYSIS" >> $GITHUB_ENV
        
        echo ""
        echo "‚úÖ Cache analysis completed"
      shell: bash
    
    - name: Implement intelligent retention policies
      if: inputs.optimization-mode == 'optimize' || inputs.optimization-mode == 'cleanup'
      id: retention-policies
      run: |
        echo "üìã INTELLIGENT RETENTION POLICIES"
        echo "================================="
        
        TOTAL_SIZE_MB=${TOTAL_SIZE_MB:-0}
        OPTIMIZATION_NEEDED=${OPTIMIZATION_NEEDED:-false}
        
        echo "üéØ Retention Policy: ${{ inputs.retention-policy }}"
        echo "Current Size: ${TOTAL_SIZE_MB}MB"
        echo "Optimization Needed: $OPTIMIZATION_NEEDED"
        echo ""
        
        # Define retention policies
        case "${{ inputs.retention-policy }}" in
          "conservative")
            echo "üìÖ Conservative Retention Policy:"
            echo "- High Priority Caches: 30 days"
            echo "- Medium Priority Caches: 14 days"
            echo "- Low Priority Caches: 7 days"
            echo "- Size-based cleanup: Only when >150% of threshold"
            
            HIGH_PRIORITY_DAYS=30
            MEDIUM_PRIORITY_DAYS=14
            LOW_PRIORITY_DAYS=7
            SIZE_CLEANUP_THRESHOLD=$(((${{ inputs.size-threshold-mb }} * 150) / 100))
            ;;
          "balanced")
            echo "üìÖ Balanced Retention Policy:"
            echo "- High Priority Caches: 14 days"
            echo "- Medium Priority Caches: 7 days"
            echo "- Low Priority Caches: 3 days"
            echo "- Size-based cleanup: When >120% of threshold"
            
            HIGH_PRIORITY_DAYS=14
            MEDIUM_PRIORITY_DAYS=7
            LOW_PRIORITY_DAYS=3
            SIZE_CLEANUP_THRESHOLD=$(((${{ inputs.size-threshold-mb }} * 120) / 100))
            ;;
          "aggressive")
            echo "üìÖ Aggressive Retention Policy:"
            echo "- High Priority Caches: 7 days"
            echo "- Medium Priority Caches: 3 days"
            echo "- Low Priority Caches: 1 day"
            echo "- Size-based cleanup: When at threshold"
            
            HIGH_PRIORITY_DAYS=7
            MEDIUM_PRIORITY_DAYS=3
            LOW_PRIORITY_DAYS=1
            SIZE_CLEANUP_THRESHOLD=${{ inputs.size-threshold-mb }}
            ;;
        esac
        
        # Store retention policy
        cat > cache-optimization/policies/retention-policy.json << EOF
        {
          "session_id": "$OPTIMIZATION_SESSION_ID",
          "timestamp": "$(date -u '+%Y-%m-%d %H:%M:%S UTC')",
          "policy": "${{ inputs.retention-policy }}",
          "retention_days": {
            "high_priority": $HIGH_PRIORITY_DAYS,
            "medium_priority": $MEDIUM_PRIORITY_DAYS,
            "low_priority": $LOW_PRIORITY_DAYS
          },
          "size_cleanup_threshold_mb": $SIZE_CLEANUP_THRESHOLD
        }
        EOF
        
        # Set environment variables
        echo "HIGH_PRIORITY_DAYS=$HIGH_PRIORITY_DAYS" >> $GITHUB_ENV
        echo "MEDIUM_PRIORITY_DAYS=$MEDIUM_PRIORITY_DAYS" >> $GITHUB_ENV
        echo "LOW_PRIORITY_DAYS=$LOW_PRIORITY_DAYS" >> $GITHUB_ENV
        echo "SIZE_CLEANUP_THRESHOLD=$SIZE_CLEANUP_THRESHOLD" >> $GITHUB_ENV
        
        echo ""
        echo "‚úÖ Retention policies configured"
      shell: bash
    
    - name: Execute cache optimization and cleanup
      if: inputs.optimization-mode == 'optimize' || inputs.optimization-mode == 'cleanup'
      id: execute-optimization
      run: |
        echo "üöÄ EXECUTING CACHE OPTIMIZATION"
        echo "=============================="
        
        TOTAL_SIZE_MB=${TOTAL_SIZE_MB:-0}
        OPTIMIZATION_NEEDED=${OPTIMIZATION_NEEDED:-false}
        SIZE_CLEANUP_THRESHOLD=${SIZE_CLEANUP_THRESHOLD:-1024}
        
        OPTIMIZATION_PERFORMED=false
        SIZE_REDUCTION_MB=0
        FILES_CLEANED=0
        
        echo "üîç Optimization Analysis:"
        echo "========================"
        echo "- Current Size: ${TOTAL_SIZE_MB}MB"
        echo "- Cleanup Threshold: ${SIZE_CLEANUP_THRESHOLD}MB"
        echo "- Optimization Needed: $OPTIMIZATION_NEEDED"
        
        if [ "$OPTIMIZATION_NEEDED" = "true" ] || [ $TOTAL_SIZE_MB -gt $SIZE_CLEANUP_THRESHOLD ]; then
          echo ""
          echo "üßπ Performing Cache Cleanup:"
          echo "=========================="
          
          OPTIMIZATION_PERFORMED=true
          
          # Parse cache analysis data
          IFS=',' read -ra CACHE_ENTRIES <<< "${CACHE_ANALYSIS:-}"
          
          for cache_entry in "${CACHE_ENTRIES[@]}"; do
            if [ -n "$cache_entry" ]; then
              IFS=':' read -r cache_name size_mb file_count age_days efficiency priority <<< "$cache_entry"
              
              # Determine cleanup action based on priority and age
              CLEANUP_ACTION="none"
              CLEANUP_REASON=""
              
              case "$priority" in
                "high")
                  if [ $age_days -gt ${HIGH_PRIORITY_DAYS:-14} ]; then
                    CLEANUP_ACTION="age_cleanup"
                    CLEANUP_REASON="Age exceeds ${HIGH_PRIORITY_DAYS} days"
                  fi
                  ;;
                "medium")
                  if [ $age_days -gt ${MEDIUM_PRIORITY_DAYS:-7} ]; then
                    CLEANUP_ACTION="age_cleanup"
                    CLEANUP_REASON="Age exceeds ${MEDIUM_PRIORITY_DAYS} days"
                  elif [ $efficiency -lt 40 ]; then
                    CLEANUP_ACTION="efficiency_cleanup"
                    CLEANUP_REASON="Low efficiency (${efficiency}%)"
                  fi
                  ;;
                "low")
                  if [ $age_days -gt ${LOW_PRIORITY_DAYS:-3} ]; then
                    CLEANUP_ACTION="age_cleanup"
                    CLEANUP_REASON="Age exceeds ${LOW_PRIORITY_DAYS} days"
                  elif [ $efficiency -lt 60 ]; then
                    CLEANUP_ACTION="efficiency_cleanup"
                    CLEANUP_REASON="Low efficiency (${efficiency}%)"
                  fi
                  ;;
              esac
              
              echo "- $cache_name (${size_mb}MB, ${age_days}d, ${efficiency}%, $priority):"
              
              if [ "$CLEANUP_ACTION" != "none" ]; then
                echo "  ‚Üí CLEANUP: $CLEANUP_REASON"
                
                # Simulate cleanup (in real implementation, would clean actual cache)
                CLEANUP_SIZE=$((size_mb / 2))  # Simulate 50% cleanup
                SIZE_REDUCTION_MB=$((SIZE_REDUCTION_MB + CLEANUP_SIZE))
                FILES_CLEANED=$((FILES_CLEANED + file_count / 2))
                
                echo "  ‚Üí Cleaned: ${CLEANUP_SIZE}MB, $((file_count / 2)) files"
              else
                echo "  ‚Üí PRESERVE: Within retention policy"
              fi
            fi
          done
          
          echo ""
          echo "üìä Cleanup Results:"
          echo "=================="
          echo "- Size Reduction: ${SIZE_REDUCTION_MB}MB"
          echo "- Files Cleaned: ${FILES_CLEANED}"
          echo "- New Total Size: $((TOTAL_SIZE_MB - SIZE_REDUCTION_MB))MB"
          
        else
          echo ""
          echo "‚úÖ No optimization needed - cache size within limits"
        fi
        
        # Calculate efficiency improvement
        EFFICIENCY_IMPROVEMENT=0
        if [ $SIZE_REDUCTION_MB -gt 0 ] && [ $TOTAL_SIZE_MB -gt 0 ]; then
          EFFICIENCY_IMPROVEMENT=$((SIZE_REDUCTION_MB * 100 / TOTAL_SIZE_MB))
        fi
        
        # Store optimization results
        cat > cache-optimization/reports/optimization-results.json << EOF
        {
          "session_id": "$OPTIMIZATION_SESSION_ID",
          "timestamp": "$(date -u '+%Y-%m-%d %H:%M:%S UTC')",
          "optimization_performed": $OPTIMIZATION_PERFORMED,
          "size_reduction_mb": $SIZE_REDUCTION_MB,
          "files_cleaned": $FILES_CLEANED,
          "efficiency_improvement": $EFFICIENCY_IMPROVEMENT,
          "original_size_mb": $TOTAL_SIZE_MB,
          "final_size_mb": $((TOTAL_SIZE_MB - SIZE_REDUCTION_MB))
        }
        EOF
        
        # Set environment variables for outputs
        echo "OPTIMIZATION_PERFORMED=$OPTIMIZATION_PERFORMED" >> $GITHUB_ENV
        echo "SIZE_REDUCTION_MB=$SIZE_REDUCTION_MB" >> $GITHUB_ENV
        echo "EFFICIENCY_IMPROVEMENT=$EFFICIENCY_IMPROVEMENT" >> $GITHUB_ENV
        
        echo ""
        echo "‚úÖ Cache optimization completed"
      shell: bash
    
    - name: Implement cache compression optimization
      if: inputs.enable-compression == 'true'
      id: compression-optimization
      run: |
        echo "üóúÔ∏è CACHE COMPRESSION OPTIMIZATION"
        echo "==============================="
        
        echo "‚ö†Ô∏è Cache Compression Analysis:"
        echo "============================="
        echo "- Compression can reduce cache size by 20-40%"
        echo "- May increase cache save/restore time by 10-20%"
        echo "- Recommended for large, infrequently accessed caches"
        echo ""
        
        # Analyze compression candidates
        echo "üéØ Compression Candidates:"
        echo "========================="
        
        # Parse cache analysis to find compression candidates
        IFS=',' read -ra CACHE_ENTRIES <<< "${CACHE_ANALYSIS:-}"
        
        COMPRESSION_SAVINGS_MB=0
        
        for cache_entry in "${CACHE_ENTRIES[@]}"; do
          if [ -n "$cache_entry" ]; then
            IFS=':' read -r cache_name size_mb file_count age_days efficiency priority <<< "$cache_entry"
            
            # Determine compression benefit
            COMPRESSION_CANDIDATE=false
            ESTIMATED_SAVINGS=0
            
            if [ $size_mb -gt 100 ] && [ $age_days -le 7 ]; then
              # Large, recent caches are good compression candidates
              COMPRESSION_CANDIDATE=true
              ESTIMATED_SAVINGS=$((size_mb * 30 / 100))  # 30% compression
            elif [ $size_mb -gt 50 ] && [ $efficiency -lt 70 ]; then
              # Medium size, low efficiency caches
              COMPRESSION_CANDIDATE=true
              ESTIMATED_SAVINGS=$((size_mb * 25 / 100))  # 25% compression
            fi
            
            echo "- $cache_name (${size_mb}MB):"
            if [ "$COMPRESSION_CANDIDATE" = "true" ]; then
              echo "  ‚Üí COMPRESS: Estimated savings ${ESTIMATED_SAVINGS}MB"
              COMPRESSION_SAVINGS_MB=$((COMPRESSION_SAVINGS_MB + ESTIMATED_SAVINGS))
            else
              echo "  ‚Üí SKIP: Not suitable for compression"
            fi
          fi
        done
        
        echo ""
        echo "üìä Compression Analysis Results:"
        echo "==============================="
        echo "- Estimated Total Savings: ${COMPRESSION_SAVINGS_MB}MB"
        echo "- Performance Impact: 10-20% slower cache operations"
        echo "- Recommendation: $([ $COMPRESSION_SAVINGS_MB -gt 200 ] && echo "ENABLE (significant savings)" || echo "SKIP (minimal benefit)")"
        
        # Store compression analysis
        cat > cache-optimization/reports/compression-analysis.json << EOF
        {
          "session_id": "$OPTIMIZATION_SESSION_ID",
          "timestamp": "$(date -u '+%Y-%m-%d %H:%M:%S UTC')",
          "compression_enabled": true,
          "estimated_savings_mb": $COMPRESSION_SAVINGS_MB,
          "performance_impact": "10-20% slower operations",
          "recommendation": "$([ $COMPRESSION_SAVINGS_MB -gt 200 ] && echo "enable" || echo "skip")"
        }
        EOF
        
        echo ""
        echo "‚úÖ Compression optimization analysis completed"
      shell: bash
    
    - name: Generate optimization recommendations and monitoring
      if: inputs.optimization-mode == 'monitor' || inputs.optimization-mode == 'optimize'
      id: monitoring-recommendations
      run: |
        echo "üìä OPTIMIZATION MONITORING & RECOMMENDATIONS"
        echo "==========================================="
        
        TOTAL_SIZE_MB=${TOTAL_SIZE_MB:-0}
        SIZE_REDUCTION_MB=${SIZE_REDUCTION_MB:-0}
        EFFICIENCY_IMPROVEMENT=${EFFICIENCY_IMPROVEMENT:-0}
        OPTIMIZATION_PERFORMED=${OPTIMIZATION_PERFORMED:-false}
        
        echo "üìà Current Optimization Status:"
        echo "=============================="
        echo "- Original Size: ${TOTAL_SIZE_MB}MB"
        echo "- Size Reduction: ${SIZE_REDUCTION_MB}MB"
        echo "- Efficiency Improvement: ${EFFICIENCY_IMPROVEMENT}%"
        echo "- Optimization Performed: $OPTIMIZATION_PERFORMED"
        echo ""
        
        echo "üí° Optimization Recommendations:"
        echo "==============================="
        
        # Generate recommendations based on current state
        RECOMMENDATIONS_COUNT=0
        
        if [ $TOTAL_SIZE_MB -gt ${{ inputs.size-threshold-mb }} ]; then
          RECOMMENDATIONS_COUNT=$((RECOMMENDATIONS_COUNT + 1))
          echo "${RECOMMENDATIONS_COUNT}. REDUCE CACHE SIZE"
          echo "   Current: ${TOTAL_SIZE_MB}MB | Target: <${{ inputs.size-threshold-mb }}MB"
          echo "   Action: Implement more aggressive retention policies"
          echo ""
        fi
        
        if [ $EFFICIENCY_IMPROVEMENT -lt 20 ] && [ "$OPTIMIZATION_PERFORMED" = "true" ]; then
          RECOMMENDATIONS_COUNT=$((RECOMMENDATIONS_COUNT + 1))
          echo "${RECOMMENDATIONS_COUNT}. IMPROVE OPTIMIZATION EFFECTIVENESS"
          echo "   Current Improvement: ${EFFICIENCY_IMPROVEMENT}% | Target: >20%"
          echo "   Action: Review cache usage patterns and retention policies"
          echo ""
        fi
        
        if [ $TOTAL_SIZE_MB -gt 500 ]; then
          RECOMMENDATIONS_COUNT=$((RECOMMENDATIONS_COUNT + 1))
          echo "${RECOMMENDATIONS_COUNT}. CONSIDER CACHE COMPRESSION"
          echo "   Current Size: ${TOTAL_SIZE_MB}MB | Potential Savings: 20-40%"
          echo "   Action: Enable compression for large, stable caches"
          echo ""
        fi
        
        # Monitoring recommendations
        echo "üìä Monitoring Recommendations:"
        echo "============================"
        echo "- Monitor cache hit rates to ensure optimization doesn't hurt performance"
        echo "- Track cache size trends over time"
        echo "- Review retention policies monthly"
        echo "- Set up alerts for cache size exceeding thresholds"
        echo ""
        
        # Future optimization opportunities
        echo "üîÆ Future Optimization Opportunities:"
        echo "==================================="
        echo "- Implement cache warming for frequently used dependencies"
        echo "- Use cache layering for different types of artifacts"
        echo "- Consider cache partitioning by workflow type"
        echo "- Implement predictive cache cleanup based on usage patterns"
        
        # Generate monitoring badge
        mkdir -p badge-data
        
        OPTIMIZATION_COLOR="red"
        OPTIMIZATION_MESSAGE="needs optimization"
        
        if [ $TOTAL_SIZE_MB -le ${{ inputs.size-threshold-mb }} ]; then
          if [ $EFFICIENCY_IMPROVEMENT -gt 20 ] || [ "$OPTIMIZATION_PERFORMED" = "false" ]; then
            OPTIMIZATION_COLOR="brightgreen"
            OPTIMIZATION_MESSAGE="optimized"
          else
            OPTIMIZATION_COLOR="green"
            OPTIMIZATION_MESSAGE="good"
          fi
        elif [ $TOTAL_SIZE_MB -le $((${{ inputs.size-threshold-mb }} * 120 / 100)) ]; then
          OPTIMIZATION_COLOR="yellow"
          OPTIMIZATION_MESSAGE="monitor"
        fi
        
        cat > badge-data/cache-optimization.json << EOF
        {
          "schemaVersion": 1,
          "label": "cache optimization",
          "message": "$OPTIMIZATION_MESSAGE",
          "color": "$OPTIMIZATION_COLOR"
        }
        EOF
        
        echo ""
        echo "‚úÖ Optimization monitoring and recommendations completed"
        echo "üè∑Ô∏è Optimization badge: $OPTIMIZATION_MESSAGE ($OPTIMIZATION_COLOR)"
      shell: bash
    
    - name: Set optimization outputs
      id: optimization-result
      run: |
        # Set outputs for monitoring and reporting
        echo "performed=${OPTIMIZATION_PERFORMED:-false}" >> $GITHUB_OUTPUT
        echo "reduction=${SIZE_REDUCTION_MB:-0}" >> $GITHUB_OUTPUT
        echo "efficiency=${EFFICIENCY_IMPROVEMENT:-0}" >> $GITHUB_OUTPUT
        
        echo "üìä Optimization outputs set for monitoring"
      shell: bash
    
    - name: Upload optimization reports and data
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: cache-optimization-reports-${{ github.run_number }}
        path: |
          cache-optimization/
          badge-data/cache-optimization.json
        retention-days: 30