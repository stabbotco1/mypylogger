# Design Document

## Overview

The file-based test coverage badge system replaces the previous API-based implementation with a reliable, fast solution that stores coverage results locally and eliminates timeout issues. The design integrates seamlessly with the existing test infrastructure while providing comprehensive coverage information through a structured results file.

## Architecture

### High-Level Architecture

```
mypylogger/
├── scripts/
│   └── run_tests.sh          # Enhanced with coverage file generation
├── docs/
│   └── test-coverage-results.md  # Generated coverage results file
├── badges/
│   ├── generator.py          # Updated coverage badge generation
│   ├── updater.py           # README update functionality
│   └── status.py            # File-based coverage reading
└── README.md                # Updated with file-linked badge
```

### Design Principles

1. **File-Based Storage**: All coverage data stored locally in structured markdown file
2. **Single Source of Truth**: `docs/test-coverage-results.md` is the authoritative coverage source
3. **Atomic Operations**: All file operations use atomic writes to prevent corruption
4. **GitHub Integration**: Badge links directly to GitHub file for detailed results
5. **Fast Execution**: No external API calls or subprocess timeouts during badge generation

## Components and Interfaces

### Enhanced Master Test Script (`scripts/run_tests.sh`)

**Purpose**: Generate test coverage results file after test execution

**New Functionality**:
```bash
# After successful test execution with coverage
generate_coverage_results_file() {
    local coverage_percentage="$1"
    local test_count="$2"
    local test_results="$3"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")
    
    # Create structured markdown file
    cat > docs/test-coverage-results.md << EOF
# Test Coverage Results

## Current Coverage: ${coverage_percentage}%

**Last Updated:** ${timestamp}

## Test Execution Summary

- **Total Tests:** ${test_count}
- **Test Results:** ${test_results}
- **Coverage Percentage:** ${coverage_percentage}%
- **Coverage Threshold:** 95% (minimum required)

## Coverage Status

$(if [ "$coverage_percentage" -ge 95 ]; then
    echo "✅ **EXCELLENT** - Coverage meets or exceeds 95% requirement"
elif [ "$coverage_percentage" -ge 90 ]; then
    echo "⚠️ **GOOD** - Coverage is above 90% but below 95% target"
else
    echo "❌ **NEEDS IMPROVEMENT** - Coverage is below 90% minimum"
fi)

## Details

This file is automatically generated by the test suite and contains the most recent test coverage results for the mypylogger project.

For detailed coverage reports, run:
\`\`\`bash
uv run pytest --cov=src --cov-report=html
\`\`\`

Then open \`htmlcov/index.html\` in your browser.
EOF
}
```

**Integration Points**:
- Extract coverage percentage from pytest-cov output
- Count total tests from pytest execution
- Generate structured markdown with timestamp
- Update README badge after file generation

### Updated Badge Generator (`badges/generator.py`)

**Purpose**: Generate coverage badge URL using file-based data

**Modified Function**:
```python
def generate_test_coverage_badge() -> str:
    """Generate test coverage badge URL using file-based coverage data.
    
    Returns:
        Shields.io URL for test coverage badge with GitHub file link.
    """
    try:
        from badges.status import get_test_coverage_from_file
        
        config = get_badge_config()
        
        # Get coverage from results file
        coverage_data = get_test_coverage_from_file()
        coverage = coverage_data.get("percentage", 95)  # Default fallback
        
        # Determine badge color based on coverage thresholds
        if coverage >= 95:
            color = "brightgreen"
        elif coverage >= 90:
            color = "yellow"  # Amber for 90-94%
        else:
            color = "red"     # Red for <90%
        
        # Generate badge URL with GitHub file link
        badge_url = f"{config.shields_base_url}/badge/coverage-{coverage}%25-{color}?style=flat"
        
        return badge_url
    except Exception as e:
        logger.warning(f"Failed to read coverage from file, using fallback: {e}")
        # Fallback to default green badge
        config = get_badge_config()
        return f"{config.shields_base_url}/badge/coverage-95%25-brightgreen?style=flat"
```

### File-Based Coverage Reader (`badges/status.py`)

**Purpose**: Read coverage data from results file

**New Function**:
```python
def get_test_coverage_from_file() -> Dict[str, Any]:
    """Get test coverage data from docs/test-coverage-results.md file.
    
    Returns:
        Dictionary containing coverage data with keys:
        - percentage: Coverage percentage as integer
        - timestamp: Last update timestamp
        - test_count: Total number of tests
        - status: Coverage status string
    """
    try:
        results_file = Path("docs/test-coverage-results.md")
        
        if not results_file.exists():
            logger.warning("Coverage results file not found, using fallback")
            return {"percentage": 95, "status": "unknown"}
        
        content = results_file.read_text(encoding="utf-8")
        
        # Parse coverage percentage from markdown
        coverage_match = re.search(r"## Current Coverage: (\d+)%", content)
        if coverage_match:
            coverage = int(coverage_match.group(1))
        else:
            logger.warning("Could not parse coverage percentage from file")
            coverage = 95
        
        # Parse timestamp
        timestamp_match = re.search(r"\*\*Last Updated:\*\* (.+)", content)
        timestamp = timestamp_match.group(1) if timestamp_match else "unknown"
        
        # Parse test count
        test_count_match = re.search(r"\*\*Total Tests:\*\* (\d+)", content)
        test_count = int(test_count_match.group(1)) if test_count_match else 0
        
        # Determine status based on coverage
        if coverage >= 95:
            status = "excellent"
        elif coverage >= 90:
            status = "good"
        else:
            status = "needs_improvement"
        
        return {
            "percentage": coverage,
            "timestamp": timestamp,
            "test_count": test_count,
            "status": status
        }
        
    except Exception as e:
        logger.error(f"Error reading coverage results file: {e}")
        return {"percentage": 95, "status": "error"}
```

### Badge Link Generation

**Purpose**: Create GitHub file links for badge clicks

**Implementation**:
```python
def get_coverage_badge_link() -> str:
    """Get GitHub link to test coverage results file.
    
    Returns:
        GitHub URL to docs/test-coverage-results.md file.
    """
    config = get_badge_config()
    repo = config.github_repo  # e.g., "username/mypylogger"
    return f"https://github.com/{repo}/blob/main/docs/test-coverage-results.md"
```

## Data Models

### Coverage Results File Structure

```markdown
# Test Coverage Results

## Current Coverage: 98%

**Last Updated:** 2025-01-31T15:30:45.123Z

## Test Execution Summary

- **Total Tests:** 156
- **Test Results:** 156 passed, 0 failed, 0 skipped
- **Coverage Percentage:** 98%
- **Coverage Threshold:** 95% (minimum required)

## Coverage Status

✅ **EXCELLENT** - Coverage meets or exceeds 95% requirement

## Details

This file is automatically generated by the test suite and contains the most recent test coverage results for the mypylogger project.

For detailed coverage reports, run:
```bash
uv run pytest --cov=src --cov-report=html
```

Then open `htmlcov/index.html` in your browser.
```

### Coverage Data Model

```python
@dataclass
class CoverageData:
    """Test coverage data structure."""
    percentage: int
    timestamp: str
    test_count: int
    test_results: str
    status: str  # "excellent", "good", "needs_improvement", "error"
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "percentage": self.percentage,
            "timestamp": self.timestamp,
            "test_count": self.test_count,
            "test_results": self.test_results,
            "status": self.status
        }
```

## Error Handling

### File Operation Errors

**Missing Results File**:
- Fallback to 95% coverage (green badge)
- Log warning about missing file
- Continue with badge generation

**Corrupted Results File**:
- Parse what data is available
- Use fallback values for missing data
- Log error details for debugging

**File Write Failures**:
- Use atomic write operations with temporary files
- Retry mechanism for transient failures
- Graceful degradation if file generation fails

### Coverage Parsing Errors

**Invalid Coverage Data**:
- Validate coverage percentage range (0-100)
- Use fallback values for invalid data
- Log parsing errors with context

**Malformed File Content**:
- Robust regex parsing with error handling
- Multiple parsing strategies for different formats
- Clear error messages for debugging

## Testing Strategy

### Unit Tests

**File-Based Coverage Reading**:
```python
def test_get_coverage_from_file_success():
    """Test successful coverage data extraction from file."""
    
def test_get_coverage_from_file_missing():
    """Test handling of missing coverage results file."""
    
def test_get_coverage_from_file_corrupted():
    """Test handling of corrupted coverage results file."""
```

**Badge Generation Tests**:
```python
def test_generate_coverage_badge_high_coverage():
    """Test badge generation with 95%+ coverage (green)."""
    
def test_generate_coverage_badge_medium_coverage():
    """Test badge generation with 90-94% coverage (amber)."""
    
def test_generate_coverage_badge_low_coverage():
    """Test badge generation with <90% coverage (red)."""
```

### Integration Tests

**End-to-End Workflow**:
```python
def test_complete_coverage_workflow():
    """Test complete workflow from test execution to badge update."""
    
def test_master_script_coverage_generation():
    """Test run_tests.sh generates correct coverage results file."""
    
def test_readme_badge_update_from_file():
    """Test README badge update using file-based coverage data."""
```

## Implementation Phases

### Phase 1: File Generation Infrastructure
1. Enhance `scripts/run_tests.sh` to generate coverage results file
2. Implement coverage data extraction from pytest output
3. Create structured markdown file generation
4. Add atomic file write operations

### Phase 2: Badge System Updates
1. Update `generate_test_coverage_badge()` to use file-based data
2. Implement `get_test_coverage_from_file()` function
3. Add GitHub file link generation
4. Update badge color logic for new thresholds

### Phase 3: README Integration
1. Update README badge to link to GitHub file
2. Integrate file-based badge generation with existing updater
3. Ensure PyPI compatibility for badge display
4. Test complete workflow integration

### Phase 4: Cleanup and Migration
1. Remove old API-based coverage badge code
2. Update all references in specs and documentation
3. Update existing tests to use file-based approach
4. Validate no conflicts with existing badge system

## Performance Considerations

### File Operations

**Fast File Access**:
- Small file size (< 2KB typical)
- Single file read per badge generation
- Cached file content within single execution

**Atomic Writes**:
- Temporary file creation and rename
- No file locking required for reads
- Minimal disk I/O overhead

### Badge Generation Speed

**No External Calls**:
- All data from local file system
- No subprocess execution during badge generation
- No network timeouts or API rate limits

**Execution Time**:
- File read: < 1ms
- Badge URL generation: < 1ms
- Total coverage badge generation: < 5ms

## Security Considerations

### File Security

**Results File Protection**:
- Read-only access for badge generation
- Write access only during test execution
- No sensitive data in coverage results

**Path Security**:
- Fixed file path prevents directory traversal
- Validate file content format before parsing
- Safe markdown generation without code injection

### GitHub Integration

**Public File Access**:
- Coverage results file committed to repository
- Public read access through GitHub web interface
- No authentication required for badge links

## Migration Strategy

### Backward Compatibility

**Existing Badge Display**:
- Maintain same badge appearance and location
- Preserve existing README badge section
- Keep same shields.io URL format

**API Compatibility**:
- Keep existing badge generation function signatures
- Maintain same return value formats
- Preserve existing configuration options

### Cleanup Process

**Remove Old Implementation**:
1. Identify all API-based coverage code
2. Update function implementations to use file-based approach
3. Remove unused subprocess calls and timeout handling
4. Update tests to match new implementation

**Update Documentation**:
1. Update all spec references to file-based approach
2. Modify design documents to reflect new architecture
3. Update task lists to remove API-based tasks
4. Add new file-based tasks and requirements

This design provides a robust, fast, and maintainable solution for test coverage badges that eliminates timeout issues while providing comprehensive coverage information through structured file storage.